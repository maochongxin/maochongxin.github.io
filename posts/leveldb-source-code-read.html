<html>
<head><meta name="generator" content="Hexo 3.9.0">
	
	<title>leveldb源码阅读随笔</title>
	<meta name="keywords" content="maochong.xin,毛崇鑫,毛崇鑫的blog">

    <meta https-equiv="content-type" content="text/html; charset=utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    
	   <link href="/css/main.css?v=3" rel="stylesheet" type="text/css">
    
        <script src="/js/util.js"></script>
        <script>
            if(isMobile()) {
                loadjscssfile('../css/mobile.css', 'css');
            } else {
                loadjscssfile('../css/desktop.css', 'css');
            }
        </script> 
    

    <link rel="alternate" type="application/atom+xml" href="/atom.xml" title="Atom feed">

    
	<link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=3">
    
    

</head>

<body>


<h2 class="title">leveldb源码阅读随笔</h2>
<!---
<div style="text-align:center;margin-top: -10px;">
<div class="article-category">
发表于2020年10月10日




 </div>
--->
</div>

<ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#数据结构"><span class="toc-text">数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#slice"><span class="toc-text">slice</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Varint"><span class="toc-text">Varint</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Key"><span class="toc-text">Key</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Log"><span class="toc-text">Log</span></a></li></ol>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h3 id="slice"><a href="#slice" class="headerlink" title="slice"></a>slice</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Slice</span> &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* data_; <span class="comment">// 外部存储, slice中不存储实际数据, 因为记录长度,允许值中存在'\0'</span></span><br><span class="line">    <span class="keyword">size_t</span> size_; <span class="comment">// 记录长度</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="Varint"><a href="#Varint" class="headerlink" title="Varint"></a>Varint</h3><p>变长整型, 多个字节表示一个数字, 最多用5个字节表示 每个字节最高位 1 表示后面的字节也是这个数字的一部分 如果是0结束</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">EncodeVarint32</span><span class="params">(<span class="keyword">char</span>* dst, <span class="keyword">uint32_t</span> v)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// Operate on characters as unsigneds</span></span><br><span class="line">    <span class="keyword">uint8_t</span>* ptr = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">uint8_t</span>*&gt;(dst);</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> B = <span class="number">128</span>;</span><br><span class="line">	<span class="keyword">if</span> (v &lt; (<span class="number">1</span> &lt;&lt; <span class="number">7</span>)) &#123;</span><br><span class="line">		*(ptr++) = v;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (v &lt; (<span class="number">1</span> &lt;&lt; <span class="number">14</span>)) &#123;</span><br><span class="line">		*(ptr++) = v | B;</span><br><span class="line">		*(ptr++) = v &gt;&gt; <span class="number">7</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (v &lt; (<span class="number">1</span> &lt;&lt; <span class="number">21</span>)) &#123;</span><br><span class="line">		*(ptr++) = v | B;</span><br><span class="line">		*(ptr++) = (v &gt;&gt; <span class="number">7</span>) | B;</span><br><span class="line">		*(ptr++) = v &gt;&gt; <span class="number">14</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (v &lt; (<span class="number">1</span> &lt;&lt; <span class="number">28</span>)) &#123;</span><br><span class="line">		*(ptr++) = v | B;</span><br><span class="line">		*(ptr++) = (v &gt;&gt; <span class="number">7</span>) | B;</span><br><span class="line">		*(ptr++) = (v &gt;&gt; <span class="number">14</span>) | B;</span><br><span class="line">		*(ptr++) = v &gt;&gt; <span class="number">21</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		*(ptr++) = v | B;</span><br><span class="line">		*(ptr++) = (v &gt;&gt; <span class="number">7</span>) | B;</span><br><span class="line">		*(ptr++) = (v &gt;&gt; <span class="number">14</span>) | B;</span><br><span class="line">		*(ptr++) = (v &gt;&gt; <span class="number">21</span>) | B;</span><br><span class="line">		*(ptr++) = v &gt;&gt; <span class="number">28</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">char</span>*&gt;(ptr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对外提供几个接口:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PutFixed32</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span>* dst, <span class="keyword">uint32_t</span> value)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PutFixed64</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span>* dst, <span class="keyword">uint64_t</span> value)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PutVarint32</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span>* dst, <span class="keyword">uint32_t</span> value)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PutVarint64</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span>* dst, <span class="keyword">uint64_t</span> value)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">GetVarint32</span><span class="params">(Slice* input, <span class="keyword">uint32_t</span>* value)</span></span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">GetVarint64</span><span class="params">(Slice* input, <span class="keyword">uint64_t</span>* value)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EncodeFixed32</span><span class="params">(<span class="keyword">char</span>* dst, <span class="keyword">uint32_t</span> value)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EncodeFixed64</span><span class="params">(<span class="keyword">char</span>* dst, <span class="keyword">uint64_t</span> value)</span> </span></span><br><span class="line"><span class="function">uint32_t <span class="title">DecodeFixed32</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* ptr)</span></span></span><br><span class="line"><span class="function">uint64_t <span class="title">DecodeFixed64</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* ptr)</span></span></span><br></pre></td></tr></table></figure>

<h2 id="Key"><a href="#Key" class="headerlink" title="Key"></a>Key</h2><p>三种Key的关系:</p>
<ul>
<li>UserKey是用户输入的Key</li>
<li>InternalKey是作为SSTable中单条Record的key</li>
<li>LookupKey是 DBImpl::Get使用的 需要一个长度去读一条Record</li>
</ul>
<p>InternalKey : 作为sstable中单条record的key</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">LookupKey</span><br><span class="line">+-----------------------------------------------------+</span><br><span class="line">|        +------------------------------------------+ |</span><br><span class="line">|        |               Internal Key               | |</span><br><span class="line">| Length +------------------------+----------+------+ |</span><br><span class="line">|        |        User Key        | Sequence | Type | |</span><br><span class="line">|        +------------------------+----------+------+ |</span><br><span class="line">+-----------------------------------------------------+</span><br></pre></td></tr></table></figure>

<h2 id="Log"><a href="#Log" class="headerlink" title="Log"></a>Log</h2><p>使用顺序写入类初始化, Log写入流程:</p>
<ol>
<li>检查当前block剩余空间(block_size - block_offset) 是否能写入Header(checksum), 如果不足, 切到一个新block, 上一个文件剩余部分用0填充</li>
<li>检查record slice是否能够一次写入, 如果不能则分段存储, 使用type标记如何存储</li>
<li>将数据组成指定格式存到磁盘<ol>
<li>创建一个header buffer char[7] (7字节 Header大小), 后三位写length和type, 前四位是根据record的信息生成的crc校检码</li>
<li>header数组、recored字符串生成slice  添加到dest指针缓冲区中 flush到磁盘</li>
<li>移动文件内偏移</li>
</ol>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">Status Writer::AddRecord(<span class="keyword">const</span> Slice&amp; slice) &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span>* ptr = slice.data();</span><br><span class="line">  <span class="keyword">size_t</span> left = slice.size();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Fragment the record if necessary and emit it.  Note that if slice</span></span><br><span class="line">  <span class="comment">// is empty, we still want to iterate once to emit a single</span></span><br><span class="line">  <span class="comment">// zero-length record</span></span><br><span class="line">  Status s;</span><br><span class="line">  <span class="keyword">bool</span> begin = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> leftover = kBlockSize - block_offset_;</span><br><span class="line">    assert(leftover &gt;= <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (leftover &lt; kHeaderSize) &#123;</span><br><span class="line">      <span class="comment">// Switch to a new block</span></span><br><span class="line">      <span class="keyword">if</span> (leftover &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// Fill the trailer (literal below relies on kHeaderSize being 7)</span></span><br><span class="line">        <span class="keyword">static_assert</span>(kHeaderSize == <span class="number">7</span>, <span class="string">""</span>);</span><br><span class="line">        dest_-&gt;Append(Slice(<span class="string">"\x00\x00\x00\x00\x00\x00"</span>, leftover));</span><br><span class="line">      &#125;</span><br><span class="line">      block_offset_ = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Invariant: we never leave &lt; kHeaderSize bytes in a block.</span></span><br><span class="line">    assert(kBlockSize - block_offset_ - kHeaderSize &gt;= <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">size_t</span> avail = kBlockSize - block_offset_ - kHeaderSize;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">size_t</span> fragment_length = (left &lt; avail) ? left : avail;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果新的slice小于avail，则该slice可用整个添加到当前Block中，</span></span><br><span class="line">    <span class="comment">// 不需要分段，此时type=kFullType</span></span><br><span class="line">    <span class="comment">// 如果slice大于等于avail，则该slice需要分段存储，如果是第一段</span></span><br><span class="line">    <span class="comment">// type = kFirstType，如果是最后一段type = kLastType，否则type = kMiddleType</span></span><br><span class="line">    RecordType type;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">bool</span> end = (left == fragment_length);</span><br><span class="line">    <span class="keyword">if</span> (begin &amp;&amp; end) &#123;</span><br><span class="line">      type = kFullType;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (begin) &#123;</span><br><span class="line">      type = kFirstType;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (end) &#123;</span><br><span class="line">      type = kLastType;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      type = kMiddleType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将数据组建成指定格式后存储到磁盘</span></span><br><span class="line">    s = EmitPhysicalRecord(type, ptr, fragment_length);</span><br><span class="line">    ptr += fragment_length;</span><br><span class="line">    left -= fragment_length;</span><br><span class="line">    begin = <span class="literal">false</span>;</span><br><span class="line">  &#125; <span class="keyword">while</span> (s.ok() &amp;&amp; left &gt; <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Status Writer::EmitPhysicalRecord(RecordType t, <span class="keyword">const</span> <span class="keyword">char</span>* ptr,</span><br><span class="line">                                  <span class="keyword">size_t</span> length) &#123;</span><br><span class="line">  assert(length &lt;= <span class="number">0xffff</span>);  <span class="comment">// Must fit in two bytes</span></span><br><span class="line">  assert(block_offset_ + kHeaderSize + length &lt;= kBlockSize);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Format the header</span></span><br><span class="line">  <span class="keyword">char</span> buf[kHeaderSize];</span><br><span class="line">  buf[<span class="number">4</span>] = <span class="keyword">static_cast</span>&lt;<span class="keyword">char</span>&gt;(length &amp; <span class="number">0xff</span>);</span><br><span class="line">  buf[<span class="number">5</span>] = <span class="keyword">static_cast</span>&lt;<span class="keyword">char</span>&gt;(length &gt;&gt; <span class="number">8</span>);</span><br><span class="line">  buf[<span class="number">6</span>] = <span class="keyword">static_cast</span>&lt;<span class="keyword">char</span>&gt;(t);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Compute the crc of the record type and the payload.</span></span><br><span class="line">  <span class="keyword">uint32_t</span> crc = crc32c::Extend(type_crc_[t], ptr, length);</span><br><span class="line">  crc = crc32c::Mask(crc);  <span class="comment">// Adjust for storage</span></span><br><span class="line">  EncodeFixed32(buf, crc);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Write the header and the payload</span></span><br><span class="line">  Status s = dest_-&gt;Append(Slice(buf, kHeaderSize));</span><br><span class="line">  <span class="keyword">if</span> (s.ok()) &#123;</span><br><span class="line">    s = dest_-&gt;Append(Slice(ptr, length));</span><br><span class="line">    <span class="keyword">if</span> (s.ok()) &#123;</span><br><span class="line">      s = dest_-&gt;Flush();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  block_offset_ += kHeaderSize + length;</span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<!--<a href="https://maochong.xin/posts/leveldb-source-code-read.html#disqus_thread" class="article-comment-link">Comments</a>
<div id="disqus_thread"></div>
<script type="text/javascript">
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
    var disqus_shortname = ''; // required: replace example with your forum shortname

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
-->
<div style="display:none">
<script src="https://s4.cnzz.com/stat.php?id=&web_id=" language="JavaScript"></script>script>
</div>






</body>
</html>