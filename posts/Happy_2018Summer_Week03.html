<html>
<head><meta name="generator" content="Hexo 3.9.0">
	
	<title>HAPPY_2018 Summer_Week03</title>
	<meta name="keywords" content="maochong.xin,毛崇鑫,毛崇鑫的blog">

    <meta https-equiv="content-type" content="text/html; charset=utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    
	   <link href="/css/main.css?v=3" rel="stylesheet" type="text/css">
    
        <script src="/js/util.js"></script>
        <script>
            if(isMobile()) {
                loadjscssfile('../css/mobile.css', 'css');
            } else {
                loadjscssfile('../css/desktop.css', 'css');
            }
        </script> 
    

    <link rel="alternate" type="application/atom+xml" href="/atom.xml" title="Atom feed">

    
	<link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=3">
    
    

</head>

<body>


<h2 class="title">HAPPY_2018 Summer_Week03</h2>
<!---
<div style="text-align:center;margin-top: -10px;">
<div class="article-category">
发表于2019年9月19日




 </div>
--->
</div>

<ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#7-1-是否同一棵二叉搜索树（25-分）"><span class="toc-text">7-1 是否同一棵二叉搜索树（25 分）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-2-还原二叉树（25-分）"><span class="toc-text">7-2 还原二叉树（25 分）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-3-树的同构（25-分）"><span class="toc-text">7-3 树的同构（25 分）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-4-朋友圈（25-分）20-25"><span class="toc-text">7-4 朋友圈（25 分）20/25</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-6-是否完全二叉搜索树（30-分）"><span class="toc-text">7-6 是否完全二叉搜索树（30 分）</span></a></li></ol>
<h2 id="7-1-是否同一棵二叉搜索树（25-分）"><a href="#7-1-是否同一棵二叉搜索树（25-分）" class="headerlink" title="7-1 是否同一棵二叉搜索树（25 分）"></a>7-1 是否同一棵二叉搜索树（25 分）</h2><p>给定一个插入序列就可以唯一确定一棵二叉搜索树。然而，一棵给定的二叉搜索树却可以由多种不同的插入序列得到。例如分别按照序列{2, 1, 3}和{2, 3, 1}插入初始为空的二叉搜索树，都得到一样的结果。于是对于输入的各种插入序列，你需要判断它们是否能生成一样的二叉搜索树。</p>
<p><strong>输入格式:</strong></p>
<p>输入包含若干组测试数据。每组数据的第1行给出两个正整数N (≤10)和L，分别是每个序列插入元素的个数和需要检查的序列个数。第2行给出N个以空格分隔的正整数，作为初始插入序列。最后L行，每行给出N个插入的元素，属于L个需要检查的序列。</p>
<p>简单起见，我们保证每个插入序列都是1到N的一个排列。当读到N为0时，标志输入结束，这组数据不要处理。</p>
<p><strong>输出格式:</strong></p>
<p>对每一组需要检查的序列，如果其生成的二叉搜索树跟对应的初始序列生成的一样，输出“Yes”，否则输出“No”。</p>
<p><strong>输入样例:</strong></p>
<pre><code>4 2
3 1 4 2
3 4 1 2
3 2 4 1
2 1
2 1
1 2
0</code></pre><p><strong>输出样例:</strong></p>
<pre><code>Yes
No
No</code></pre><p>我在网上查了发现有三种思路,我自己的思路是最朴素最暴力的一种,就是两个序列分别建树,然后对比是否相同.有一点需要注意的是这个树可能是一棵斜向的搜索树,也就是给定的序列是递增的,所以说在检索时,检索的长度时给定的序列长度n的四倍.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> BST1[<span class="number">1000000</span>];</span><br><span class="line"><span class="keyword">int</span> BST2[<span class="number">1000000</span>];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Build</span><span class="params">(<span class="keyword">int</span> k,<span class="keyword">int</span> data,<span class="keyword">int</span>* BST)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (data &gt;= BST1[k]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (BST[<span class="number">2</span> * k + <span class="number">1</span>] == <span class="number">-1</span>) &#123;</span><br><span class="line">            BST[<span class="number">2</span> * k + <span class="number">1</span>] = data;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Build(k * <span class="number">2</span> + <span class="number">1</span>, data,BST);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(BST[<span class="number">2</span> * k] == <span class="number">-1</span>) &#123;</span><br><span class="line">            BST[<span class="number">2</span> * k] = data;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Build(<span class="number">2</span> * k, data,BST);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> L;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;n) != EOF &amp;&amp; n) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(BST1,<span class="number">-1</span>,<span class="keyword">sizeof</span>(BST1));</span><br><span class="line">        <span class="keyword">int</span> x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;L);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,BST1 + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;x);</span><br><span class="line">            Build(<span class="number">1</span>, x, BST1);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (L--) &#123;</span><br><span class="line">            <span class="built_in">memset</span>(BST2,<span class="number">-1</span>,<span class="keyword">sizeof</span>(BST2));</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,BST2 + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;x);</span><br><span class="line">                Build(<span class="number">1</span>, x, BST2);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> i;</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= <span class="number">4</span> * n; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (BST1[i] != BST2[i]) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">4</span> * n + <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="built_in">puts</span>(<span class="string">"Yes"</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">puts</span>(<span class="string">"No"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二种思路是根据根节点把序列分为左右两个字树</p>
<p>例如 3 1 2 4 和 3 4 1 2</p>
<p>这里分别划成了 {1, 2} 3 {4} 和 {1, 2} 3 {4}</p>
<p>如果是 3 1 2 4 和 3 2 4 1</p>
<p>则是划成了 {1, 2} 3 {4} 和 {2 , 1} 3 {4} </p>
<p>如此便可以判断是否是同一棵树</p>
<p>第三种是建树然后比较两个树的节点是否一样.</p>
<h2 id="7-2-还原二叉树（25-分）"><a href="#7-2-还原二叉树（25-分）" class="headerlink" title="7-2 还原二叉树（25 分）"></a>7-2 还原二叉树（25 分）</h2><p>给定一棵二叉树的先序遍历序列和中序遍历序列，要求计算该二叉树的高度。</p>
<p><strong>输入格式:</strong></p>
<p>输入首先给出正整数N（≤50），为树中结点总数。下面两行先后给出先序和中序遍历序列，均是长度为N的不包含重复英文字母（区别大小写）的字符串。</p>
<p><strong>输出格式:</strong></p>
<p>输出为一个整数，即该二叉树的高度。</p>
<p><strong>输入样例:</strong></p>
<pre><code>9
ABDFGHIEC
FDHGIBEAC</code></pre><p>输出样例:</p>
<pre><code>5</code></pre><p>这个是上课讲的原题,就是根据先序序列确定树根,然后在中序序列中找到树根的位置就能将中序序列划分为左右子树,然后递归这个过程就能还原这棵树.</p>
<p>确定这棵树的高度就是找左右子树最大高度加1 因为有个树根,因此也是个递归.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> pre[<span class="number">10000</span>];</span><br><span class="line"><span class="keyword">char</span> in[<span class="number">10000</span>];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BST</span>* <span class="title">Tree</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BST</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> data;</span><br><span class="line">    Tree left;</span><br><span class="line">    Tree right;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span> <span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &gt; y ? x : y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//ABDFGHIEC</span></span><br><span class="line"><span class="comment">//FDHGIBEAC</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1 8</span></span><br><span class="line"><span class="function">Tree <span class="title">Insert</span><span class="params">(<span class="keyword">char</span>* _pre,<span class="keyword">char</span>* _in,<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    Tree t;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        t = <span class="literal">NULL</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        t = (Tree)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct BST));</span><br><span class="line">        t -&gt; data = *_pre;</span><br><span class="line">        <span class="keyword">char</span> *p = _in;</span><br><span class="line">        <span class="keyword">while</span>(*p != *_pre &amp;&amp; p)&#123;</span><br><span class="line">            p++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> len = p - _in;</span><br><span class="line">        t -&gt; left = Insert(_pre + <span class="number">1</span>, _in, len);</span><br><span class="line">        t -&gt; right = Insert(_pre + len + <span class="number">1</span>, p + <span class="number">1</span>, n - len - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getHeight</span><span class="params">(Tree t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>,r = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (t) &#123;</span><br><span class="line">        l = getHeight(t -&gt; left);</span><br><span class="line">        r = getHeight(t -&gt; right);</span><br><span class="line">        <span class="keyword">return</span> max(l, r) + <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    Tree t;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    getchar();</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s %s"</span>,pre,in);</span><br><span class="line">    t = Insert(pre, in, n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,getHeight(t));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="7-3-树的同构（25-分）"><a href="#7-3-树的同构（25-分）" class="headerlink" title="7-3 树的同构（25 分）"></a>7-3 树的同构（25 分）</h2><p>给定两棵树T1和T2。如果T1可以通过若干次左右孩子互换就变成T2，则我们称两棵树是“同构”的。例如图1给出的两棵树就是同构的，因为我们把其中一棵树的结点A、B、G的左右孩子互换后，就得到另外一棵树。而图2就不是同构的。</p>
<p><img src="https://images.ptausercontent.com/28" alt><br>图1<br><img src="https://images.ptausercontent.com/29" alt><br>图2</p>
<p>现给定两棵树，请你判断它们是否是同构的。</p>
<p><strong>输入格式:</strong></p>
<p>输入给出2棵二叉树树的信息。对于每棵树，首先在一行中给出一个非负整数N (≤10)，即该树的结点数（此时假设结点从0到N−1编号）；随后N行，第i行对应编号第i个结点，给出该结点中存储的1个英文大写字母、其左孩子结点的编号、右孩子结点的编号。如果孩子结点为空，则在相应位置上给出“-”。给出的数据间用一个空格分隔。注意：题目保证每个结点中存储的字母是不同的。</p>
<p><strong>输出格式:</strong></p>
<p>如果两棵树是同构的，输出“Yes”，否则输出“No”。</p>
<p><strong>输入样例1（对应图1）：</strong></p>
<pre><code>8
A 1 2
B 3 4
C 5 -
D - -
E 6 -
G 7 -
F - -
H - -
8
G - 4
B 7 6
F - -
A 5 1
H - -
C 0 -
D - -
E 2 -</code></pre><p><strong>输出样例1:</strong></p>
<pre><code>Yes</code></pre><p><strong>输入样例2（对应图2）：</strong></p>
<pre><code>8
B 5 7
F - -
A 0 3
C 6 -
H - -
D - -
G 4 -
E 1 -
8
D 6 -
B 5 -
E - -
H - -
C 0 2
G - 3
F - -
A 1 4</code></pre><p><strong>输出样例2:</strong></p>
<pre><code>No</code></pre><p>建树的过程需要两个临时char类型变量接收左右子树的地址,如果左右子树存在(不是’-‘)那么就在数组中标记出来,因为给定的是连续的一串序列,所以没有被标记的就是根节点.</p>
<p>然后是判断同构 这里分为几种情况:</p>
<ul>
<li>两棵树都是空树 </li>
<li>两棵树一棵为空树 一棵不为空树 </li>
<li>两棵树都不是空树<ul>
<li>两棵树的根节点不同</li>
<li>两棵树根节点相同 左子树相同</li>
</ul>
</li>
</ul>
<p>针对最后一种情况,还有两种情况, 如果左子树相同了,那么就可以去判断右子树,如果不同,那么判断一下左右子树交换之后是否相同.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> data;</span><br><span class="line">    <span class="keyword">int</span> left;</span><br><span class="line">    <span class="keyword">int</span> right;</span><br><span class="line">&#125;t1[<span class="number">100</span>],t2[<span class="number">100</span>];</span><br><span class="line"><span class="keyword">int</span> TreeNode[<span class="number">100</span>];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Build</span><span class="params">(struct Node* t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">memset</span>(TreeNode,<span class="number">0</span>,<span class="keyword">sizeof</span>(TreeNode));</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    getchar();</span><br><span class="line">    <span class="keyword">char</span> left,right;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%c %c %c"</span>,&amp;t[i].data,&amp;left,&amp;right);</span><br><span class="line">        getchar();</span><br><span class="line">        <span class="keyword">if</span> (left == <span class="string">'-'</span>) &#123;</span><br><span class="line">            t[i].left = <span class="number">-1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            t[i].left = left - <span class="string">'0'</span>;</span><br><span class="line">            TreeNode[t[i].left] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (right == <span class="string">'-'</span>) &#123;</span><br><span class="line">            t[i].right = <span class="number">-1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            t[i].right = right - <span class="string">'0'</span>;</span><br><span class="line">            TreeNode[t[i].right] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> root = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (TreeNode[i] == <span class="number">0</span>) &#123;</span><br><span class="line">            root = i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">judge</span><span class="params">(<span class="keyword">int</span> _t1,<span class="keyword">int</span> _t2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (_t1 == <span class="number">-1</span> &amp;&amp; _t2 == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((_t1 == <span class="number">-1</span> &amp;&amp; _t2 != <span class="number">-1</span>) || (_t1 != <span class="number">-1</span> &amp;&amp; _t2 == <span class="number">-1</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (t1[_t1].data != t2[_t2].data) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (t1[_t1].left == <span class="number">-1</span> &amp;&amp; t2[_t2].left == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> judge(t1[_t1].right, t2[_t2].right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (t1[_t1].left != <span class="number">-1</span> &amp;&amp;  t2[_t2].left != <span class="number">-1</span> &amp;&amp; t1[t1[_t1].left].data == t2[t2[_t2].left].data) &#123;</span><br><span class="line">        <span class="keyword">return</span> judge(t1[_t1].right, t2[_t2].right) &amp;&amp; judge(t1[_t1].left, t2[_t2].left);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> judge(t1[_t1].right, t2[_t2].left) &amp;&amp; judge(t1[_t1].left,t2[_t2].right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> root1,root2;</span><br><span class="line">    root1 = Build(t1);</span><br><span class="line">    root2 = Build(t2);</span><br><span class="line">    <span class="keyword">if</span> (judge(root1, root2)) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"Yes"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"No"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="7-4-朋友圈（25-分）20-25"><a href="#7-4-朋友圈（25-分）20-25" class="headerlink" title="7-4 朋友圈（25 分）20/25"></a>7-4 朋友圈（25 分）20/25</h2><p>某学校有N个学生，形成M个俱乐部。每个俱乐部里的学生有着一定相似的兴趣爱好，形成一个朋友圈。一个学生可以同时属于若干个不同的俱乐部。根据“我的朋友的朋友也是我的朋友”这个推论可以得出，如果A和B是朋友，且B和C是朋友，则A和C也是朋友。请编写程序计算最大朋友圈中有多少人。</p>
<p><strong>输入格式:</strong></p>
<p>输入的第一行包含两个正整数N（≤30000）和M（≤1000），分别代表学校的学生总数和俱乐部的个数。后面的M行每行按以下格式给出1个俱乐部的信息，其中学生从1~N编号：</p>
<p>第i个俱乐部的人数Mi（空格）学生1（空格）学生2 … 学生Mi</p>
<p><strong>输出格式:</strong></p>
<p>输出给出一个整数，表示在最大朋友圈中有多少人。</p>
<p><strong>输入样例:</strong></p>
<pre><code>7 4
3 1 2 3
2 1 4
3 5 6 7
1 6</code></pre><p><strong>输出样例:</strong></p>
<pre><code>4</code></pre><p>一道并查集的题.</p>
<p>将每个团队的第一个人设为参照,其余的人都是他的子节点,然后遍历查找1——N的每个人的头节点,例如i是一名同学,那么find(i)也就是i的朋友的那个代表,每找到一个find(i)就在数组里对这个下标所在的位置加1,也就是这个圈子的人数加1,最后找出最大值就行.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> pre[<span class="number">30010</span>];</span><br><span class="line"><span class="keyword">int</span> sum[<span class="number">30010</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">30010</span>; i++) &#123;</span><br><span class="line">        pre[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> _find(<span class="keyword">int</span> x) &#123;</span><br><span class="line">    <span class="keyword">if</span> (pre[x] != x) &#123;</span><br><span class="line">        pre[x] = _find(pre[x]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>  pre[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">join</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fx = _find(x);</span><br><span class="line">    <span class="keyword">int</span> fy = _find(y);</span><br><span class="line">    <span class="keyword">if</span>(fx != fy) &#123;</span><br><span class="line">        pre[fx] = fy;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> n,k;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;k);</span><br><span class="line">    init ();</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;x);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; x; j++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;pre[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt; x; k++) &#123;</span><br><span class="line">            join(pre[<span class="number">0</span>],pre[k]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> t = _find(i);</span><br><span class="line">        sum[t]++;</span><br><span class="line">        <span class="keyword">if</span>(ans &lt; sum[t]) &#123;</span><br><span class="line">            ans = sum[t];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="7-6-是否完全二叉搜索树（30-分）"><a href="#7-6-是否完全二叉搜索树（30-分）" class="headerlink" title="7-6 是否完全二叉搜索树（30 分）"></a>7-6 是否完全二叉搜索树（30 分）</h2><p>将一系列给定数字顺序插入一个初始为空的二叉搜索树（定义为左子树键值大，右子树键值小），你需要判断最后的树是否一棵完全二叉树，并且给出其层序遍历的结果。</p>
<p><strong>输入格式：</strong></p>
<p>输入第一行给出一个不超过20的正整数N；第二行给出N个互不相同的正整数，其间以空格分隔。</p>
<p><strong>输出格式：</strong></p>
<p>将输入的N个正整数顺序插入一个初始为空的二叉搜索树。在第一行中输出结果树的层序遍历结果，数字间以1个空格分隔，行的首尾不得有多余空格。第二行输出YES，如果该树是完全二叉树；否则输出NO。</p>
<p><strong>输入样例1：</strong></p>
<pre><code>9
38 45 42 24 58 30 67 12 51</code></pre><p><strong>输出样例1：</strong></p>
<pre><code>38 45 24 58 42 30 12 67 51
YES</code></pre><p><strong>输入样例2：</strong></p>
<pre><code>8
38 24 12 45 58 67 42 51</code></pre><p><strong>输出样例2：</strong></p>
<pre><code>38 45 24 58 42 12 67 51
NO</code></pre><p>做了一部分题,发现BST的题目有时候是不需要真正的用指针去建树的,用数组模拟即可.</p>
<p>完全二叉树的定义: 若设二叉树的深度为h，除第 h 层外，其它各层 (1～h-1) 的结点数都达到最大个数，第 h 层所有的结点都连续集中在最左边，这就是完全二叉树。</p>
<p>叶子结点只可能在最大的两层上出现,对任意结点，若其右分支下的子孙最大层次为L，则其左分支下的子孙的最大层次必为L 或 L+1；</p>
<p>那么判断思路就是:</p>
<ul>
<li>1、如果树为空，则直接返回错。 </li>
<li>2、如果树不为空：层序遍历二叉树。 </li>
<li>3、如果一个结点左右孩子都不为空，将其左右孩子入队列； </li>
<li>4、如果遇到一个结点，左孩子为空，右孩子不为空，则该树一定不是完全二叉树； </li>
<li>5、如果遇到一个结点，左孩子不为空，右孩子为空；或者左右孩子都为空；则该节点之后 的队列中的结点都为叶子节点；该树才是完全二叉树，否则就不是完全二叉树；</li>
</ul>
<p>那么这道题就是在建完树之后,进行n次循环来输出层序遍历(建好的树的数据的存放顺序就是层序遍历).遇到-1(空节点)计数,理想情况(完全二叉树)正好等于节点数 + 1,如果不满足则不是完全二叉树</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> tree[<span class="number">1000</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> index,<span class="keyword">int</span> data)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(tree[index] == <span class="number">-1</span>) &#123;</span><br><span class="line">        tree[index] = data;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (data &gt; tree[index]) &#123;</span><br><span class="line">        insert(index * <span class="number">2</span>, data);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        insert(index * <span class="number">2</span> + <span class="number">1</span>, data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="built_in">memset</span>(tree, <span class="number">-1</span>, <span class="keyword">sizeof</span>(tree));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;data);</span><br><span class="line">        insert(<span class="number">1</span>, data);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>,i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(tree[i] == <span class="number">-1</span>) i++;</span><br><span class="line">        <span class="keyword">if</span>(k == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d"</span>,tree[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">" %d"</span>,tree[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">        k++;</span><br><span class="line">        <span class="keyword">if</span> (k == n) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="keyword">if</span> (i == n + <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"YES\n"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"NO\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<!--<a href="https://maochong.xin/posts/Happy_2018Summer_Week03.html#disqus_thread" class="article-comment-link">Comments</a>
<div id="disqus_thread"></div>
<script type="text/javascript">
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
    var disqus_shortname = ''; // required: replace example with your forum shortname

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
-->
<div style="display:none">
<script src="https://s4.cnzz.com/stat.php?id=&web_id=" language="JavaScript"></script>script>
</div>






</body>
</html>